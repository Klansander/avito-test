[![Golang](https://img.shields.io/badge/Go-v1.22-EEEEEE?logo=go&logoColor=white&labelColor=00ADD8)](https://go.dev/)
[![License](https://img.shields.io/badge/license-MIT-green)](LICENSE)

<div align="center">
    <h1>Сервис баннеров</h1>
    <h5>
        Cервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.
    </h5>
</div>

---

## Используемые технологии:
- [Golang](https://go.dev), [PostgreSQL](https://www.postgresql.org/)
- [Docker](https://www.docker.com/),
- [REST](https://ru.wikipedia.org/wiki/REST), [Swagger UI](https://swagger.io/tools/swagger-ui/)


---

## Установка
```shell
git clone git@github.com/zenorachi/dynamic-user-segmentation.git
```

---

## Начало работы


1. **Запуск сервиса:**
```shell
make
```


2. **Чтобы протестировать работу сервиса, можно перейти по адресу
   http://localhost:8000/docs/index.html для получения Swagger документации.**


## Дополнительные возможности
1. **Запуск тестов**
```shell
make test.integration
```

2. **Запуск линтера**
```shell
make lint
```

3. **Обновление swagger**
```shell
make swag
```

4. **Остановка всех запущенных контейнеров**
```shell
make clean
```

## Примеры запросов

### Получение баннера

#### Успешный запрос баннера 5 минутной давности
![get_request](materials/get200.png)
#### Успешный запрос актуального баннера
![get_request](materials/get200(1).png)
#### Нет токена 
В Заголовке "to
![get_request](materials/get401.png)
#### Нет прав доступа 
![get_request](materials/get403.png)
#### Некорректные данные
![get_request](materials/get400.png)
#### Баннер не найден
![get_request](materials/get404.png)

### Получение списка баннеров

#### Успешный запрос 
![list_request](materials/list200.png)
#### Нет токена 
![list_request](materials/list401.png)
#### Нет прав доступа 
![list_request](materials/list403.png)



### Создание баннера

#### Успешный запрос 
![post_request](materials/post201.png)
#### Нет токена 
![post_request](materials/post401.png)
#### Нет прав доступа 
![post_request](materials/post403.png)
#### Некорректные данные
![post_request](materials/post400.png)


### Обновление баннера

#### Успешный запрос
![patch_request](materials/patch200.png) 
#### Нет токена 
![patch_request](materials/patch401.png)
#### Нет прав доступа 
![patch_request](materials/patch403.png)
#### Некорректные данные
![patch_request](materials/patch400.png)
#### Баннер не найден
![patch_request](materials/patch404.png)

### Удаление баннера

#### Успешный запрос 
![del_request](materials/del204.png)
#### Нет токена 
![del_request](materials/del401.png)
#### Нет прав доступа 
![del_request](materials/del403.png)
#### Некорректные данные
![del_request](materials/del400.png)
#### Баннер не найден
![del_request](materials/del404.png)

### Удаление баннера по тэгу или фиче

#### Успешный запрос 
![delby_request](materials/delby204.png)
#### Нет токена 
![delby_request](materials/delby401.png)
#### Нет прав доступа 
![delby_request](materials/delby403.png)
#### Некорректные данные
![delby_request](materials/delby400.png)
#### Баннер не найден
![delby_request](materials/delby404.png)

### Получение версий баннера

#### Получение всех версий
![ver_request](materials/ver_full.png)
#### Получение конкретной версии
![ver_request](materials/ver_2.png)
#### Нет токена 
![ver_request](materials/ver401.png)
#### Нет прав доступа 
![ver_request](materials/ver401.png)
#### Некорректные данные
![ver_request](materials/ver400.png)
#### Баннер не найден
![ver_request](materials/ver404.png)


## Принятые решения
В процессе реализации проекта принял следующие решения, касающиеся некоторых спорных вопросов:

* **Как реализовать связь *many-to-many* между пользователями и сегментами?**
> **Решение:** решил, что будет правильнее использовать связующую таблицу `relations` для хранения связей.
Такой подход позволяет легко масштабировать приложение в будущем, не меняя текущую структуру.
Упрощаются запросы на добавление сегментов пользователю, а также их удаление.

* **Какой метод запроса лучше использовать при добавлении сегментов пользователю (*POST* или *PUT*)?**
> **Решение:** решил, что будет правильнее использовать метод *POST*, так как идет создание новых связей между пользователями и сегментами.

* **Почему в связующей таблице `relations` ID пользователя и сегмента не являются ссылками?**
> **Решение:** изначально так и было. Из плюсов: не нужно ничего делать для обновления отношений, если
сегмент будет удален. Из минусов: если удаляется сегмент, все связанные с ним отношения тоже удаляются - это хорошо, но
при этом мы теряем историю операций. Поэтому было принято решение отказаться от использования ссылок и написать TRIGGER-функцию,
которая будет реагировать на удаление сегмента, стирать все связи с удаленным сегментом и вносить все в таблицу `operations`.

* **Как реализовать автоматическое удаление пользователей из сегментов?**
> **Решение:** стоял выбор между написанием отдельного сервиса, который будет с определенной периодичностью (например, с помощью `time.Ticker` или утилиты `cron`)
выполнять проверку, не истек ли срок действия отношения пользователя к сегменту / сегментам, либо же просто
запускать отдельную горутину, если TTL указан в запросе, которая с помощью конструкции `select` будет ждать заданное время (либо завершения контекста), а затем удалять
сегменты у пользователей. Выбранный вариант довольно прост в реализации, к тому же в методе удаления
сегментов у пользователя уже был реализован функционал внесения операции в таблицу `operations`, что тоже
сильно упрощает работу. Но, стоит отметить, что у данного подхода есть и свои минусы, как, например,
запуск большого количества горутин (настолько большого, что у нас закончится оперативная память), либо другие подобные
неблагоприятные сценарии, которые могут нарушить работу сервиса. Поэтому, если бы приложение выходило не в "тестовом" режиме,
конечно, необходимо было бы использовать первый вариант, но в данном случае, для ускорения выполнения проекта все-таки решил остановиться на втором.

* **Как реализовать автоматическое добавление пользователей?**
> **Решение:** не смог придумать ничего лучше, кроме как написать TRIGGER-функцию, которая будет реагировать
на добавление записей в таблицу `segments`. Если добавились новые сегменты, функция проверяет процент автоматического
добавления (*указывается опционально в запросе на создание сегмента*), если он больше нуля, функция делает случайную
выборку из всех пользователей (исходя из заданного процента) и затем добавляет выбранным пользователям созданный сегмент,
а также вносит информацию о проделанной операции в таблицу `operations`. Такое решение имеет свои плюсы, как, например,
простота и скорость реализации. Но есть и минусы. Проблема в том, что данный подход имеет место, только в том случае,
если у нас уже есть готовая база пользователей. Если ее нет, то и весь смысл функции пропадает. Мне показалось
в какой-то степени логичным создавать новые сегменты и тестировать их на уже готовой базе пользователей, поэтому
решил оставить данное решение.

* **Какой сервис использовать для формирования ссылки на csv-файл?**
> **Решение:** как только задание было прочитано, сразу понял, что, вероятнее всего, буду использовать S3 хранилище, так как
уже имел опыт работы с S3 в проекте [**ImageBox**](https://github.com/zenorachi/image-box). Но не могу скрывать, что мне очень
понравилась идея кандидата на стажировку 2022 года использовать сервис Google Drive, поэтому я решил попробовать для себя что-то
новое и реализовал формирование ссылки на csv-файл с помощью интеграции Google Drive API.

* **Стоит ли возвращать ошибку, если у пользователя (сегмента) нет активных сегментов (пользователей)?**
> **Решение:** подумал, это будет лишним и не совсем уместным, ведь запрос обрабатывается верно,
просто не существует активных отношений между пользователями и сегментами.

* **Стоит ли использовать *multistage build*?**
> **Решение:** подумал, что это будет лишним, так как сильно увеличится время сборки.